/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * Script Factory API
 * API for UGC Script Factory
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdminControllerApproveRequest201,
  AdminControllerGetQueueJobsParams,
  AdminControllerGetRequestsParams,
  AdminUserDetailDto,
  AuthResponseDto,
  BatchDto,
  CheckoutUrlDto,
  ConsumeMagicLinkDto,
  CreateBatchDto,
  CreateDraftDto,
  CreatePersonaDto,
  CreateProjectDto,
  CreditTransactionDto,
  CreditsBalancesResponseDto,
  DeleteAccountResultDto,
  DraftDto,
  ExportResultDto,
  FinalizeDraftDto,
  FinalizeResultDto,
  GrantCreditsDto,
  GrantCreditsResponseDto,
  ImportResultDto,
  ImportUrlDto,
  MessageDto,
  PersonaResponseDto,
  ProfileDto,
  ProjectDto,
  ProjectListItemDto,
  RecentScriptDto,
  RegenerateDto,
  RequestMagicLinkDto,
  ScriptDto,
  SubscriptionInfoDto,
  UpdateDraftDto,
  UpdatePersonaDto,
  UpdateProfileDto,
  UpdateProjectDto,
  UpdateUserPlanDto,
  UserDto
} from './models';

import { customInstance } from '../customInstance';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Request a magic link for authentication
 */
export type authControllerRequestLinkResponse201 = {
  data: MessageDto
  status: 201
}
    
export type authControllerRequestLinkResponseSuccess = (authControllerRequestLinkResponse201) & {
  headers: Headers;
};
;

export type authControllerRequestLinkResponse = (authControllerRequestLinkResponseSuccess)

export const getAuthControllerRequestLinkUrl = () => {


  

  return `/auth/request-link`
}

export const authControllerRequestLink = async (requestMagicLinkDto: RequestMagicLinkDto, options?: RequestInit): Promise<authControllerRequestLinkResponse> => {
  
  return customInstance<authControllerRequestLinkResponse>(getAuthControllerRequestLinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      requestMagicLinkDto,)
  }
);}




export const getAuthControllerRequestLinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRequestLink>>, TError,{data: RequestMagicLinkDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRequestLink>>, TError,{data: RequestMagicLinkDto}, TContext> => {

const mutationKey = ['authControllerRequestLink'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRequestLink>>, {data: RequestMagicLinkDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRequestLink(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRequestLinkMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRequestLink>>>
    export type AuthControllerRequestLinkMutationBody = RequestMagicLinkDto
    export type AuthControllerRequestLinkMutationError = unknown

    /**
 * @summary Request a magic link for authentication
 */
export const useAuthControllerRequestLink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRequestLink>>, TError,{data: RequestMagicLinkDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRequestLink>>,
        TError,
        {data: RequestMagicLinkDto},
        TContext
      > => {
      return useMutation(getAuthControllerRequestLinkMutationOptions(options), queryClient);
    }
    
/**
 * @summary Consume a magic link token and authenticate
 */
export type authControllerConsumeLinkResponse201 = {
  data: AuthResponseDto
  status: 201
}
    
export type authControllerConsumeLinkResponseSuccess = (authControllerConsumeLinkResponse201) & {
  headers: Headers;
};
;

export type authControllerConsumeLinkResponse = (authControllerConsumeLinkResponseSuccess)

export const getAuthControllerConsumeLinkUrl = () => {


  

  return `/auth/consume-link`
}

export const authControllerConsumeLink = async (consumeMagicLinkDto: ConsumeMagicLinkDto, options?: RequestInit): Promise<authControllerConsumeLinkResponse> => {
  
  return customInstance<authControllerConsumeLinkResponse>(getAuthControllerConsumeLinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      consumeMagicLinkDto,)
  }
);}




export const getAuthControllerConsumeLinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConsumeLink>>, TError,{data: ConsumeMagicLinkDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerConsumeLink>>, TError,{data: ConsumeMagicLinkDto}, TContext> => {

const mutationKey = ['authControllerConsumeLink'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerConsumeLink>>, {data: ConsumeMagicLinkDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerConsumeLink(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerConsumeLinkMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerConsumeLink>>>
    export type AuthControllerConsumeLinkMutationBody = ConsumeMagicLinkDto
    export type AuthControllerConsumeLinkMutationError = unknown

    /**
 * @summary Consume a magic link token and authenticate
 */
export const useAuthControllerConsumeLink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConsumeLink>>, TError,{data: ConsumeMagicLinkDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerConsumeLink>>,
        TError,
        {data: ConsumeMagicLinkDto},
        TContext
      > => {
      return useMutation(getAuthControllerConsumeLinkMutationOptions(options), queryClient);
    }
    
/**
 * @summary Logout the current user
 */
export type authControllerLogoutResponse201 = {
  data: MessageDto
  status: 201
}
    
export type authControllerLogoutResponseSuccess = (authControllerLogoutResponse201) & {
  headers: Headers;
};
;

export type authControllerLogoutResponse = (authControllerLogoutResponseSuccess)

export const getAuthControllerLogoutUrl = () => {


  

  return `/auth/logout`
}

export const authControllerLogout = async ( options?: RequestInit): Promise<authControllerLogoutResponse> => {
  
  return customInstance<authControllerLogoutResponse>(getAuthControllerLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAuthControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
          

          return  authControllerLogout(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    
    export type AuthControllerLogoutMutationError = unknown

    /**
 * @summary Logout the current user
 */
export const useAuthControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerLogoutMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get the current authenticated user
 */
export type authControllerMeResponse200 = {
  data: UserDto
  status: 200
}
    
export type authControllerMeResponseSuccess = (authControllerMeResponse200) & {
  headers: Headers;
};
;

export type authControllerMeResponse = (authControllerMeResponseSuccess)

export const getAuthControllerMeUrl = () => {


  

  return `/auth/me`
}

export const authControllerMe = async ( options?: RequestInit): Promise<authControllerMeResponse> => {
  
  return customInstance<authControllerMeResponse>(getAuthControllerMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthControllerMeQueryKey = () => {
    return [
    `/auth/me`
    ] as const;
    }

    
export const getAuthControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = unknown


export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current authenticated user
 */

export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new project
 */
export type projectsControllerCreateResponse201 = {
  data: ProjectDto
  status: 201
}
    
export type projectsControllerCreateResponseSuccess = (projectsControllerCreateResponse201) & {
  headers: Headers;
};
;

export type projectsControllerCreateResponse = (projectsControllerCreateResponseSuccess)

export const getProjectsControllerCreateUrl = () => {


  

  return `/projects`
}

export const projectsControllerCreate = async (createProjectDto: CreateProjectDto, options?: RequestInit): Promise<projectsControllerCreateResponse> => {
  
  return customInstance<projectsControllerCreateResponse>(getProjectsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createProjectDto,)
  }
);}




export const getProjectsControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerCreate>>, TError,{data: CreateProjectDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerCreate>>, TError,{data: CreateProjectDto}, TContext> => {

const mutationKey = ['projectsControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerCreate>>, {data: CreateProjectDto}> = (props) => {
          const {data} = props ?? {};

          return  projectsControllerCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerCreate>>>
    export type ProjectsControllerCreateMutationBody = CreateProjectDto
    export type ProjectsControllerCreateMutationError = unknown

    /**
 * @summary Create a new project
 */
export const useProjectsControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerCreate>>, TError,{data: CreateProjectDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerCreate>>,
        TError,
        {data: CreateProjectDto},
        TContext
      > => {
      return useMutation(getProjectsControllerCreateMutationOptions(options), queryClient);
    }
    
/**
 * @summary List all projects
 */
export type projectsControllerFindAllResponse200 = {
  data: ProjectListItemDto[]
  status: 200
}
    
export type projectsControllerFindAllResponseSuccess = (projectsControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type projectsControllerFindAllResponse = (projectsControllerFindAllResponseSuccess)

export const getProjectsControllerFindAllUrl = () => {


  

  return `/projects`
}

export const projectsControllerFindAll = async ( options?: RequestInit): Promise<projectsControllerFindAllResponse> => {
  
  return customInstance<projectsControllerFindAllResponse>(getProjectsControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getProjectsControllerFindAllQueryKey = () => {
    return [
    `/projects`
    ] as const;
    }

    
export const getProjectsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerFindAll>>> = ({ signal }) => projectsControllerFindAll({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerFindAll>>>
export type ProjectsControllerFindAllQueryError = unknown


export function useProjectsControllerFindAll<TData = Awaited<ReturnType<typeof projectsControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFindAll<TData = Awaited<ReturnType<typeof projectsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFindAll<TData = Awaited<ReturnType<typeof projectsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all projects
 */

export function useProjectsControllerFindAll<TData = Awaited<ReturnType<typeof projectsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get a project by ID
 */
export type projectsControllerFindOneResponse200 = {
  data: ProjectDto
  status: 200
}
    
export type projectsControllerFindOneResponseSuccess = (projectsControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type projectsControllerFindOneResponse = (projectsControllerFindOneResponseSuccess)

export const getProjectsControllerFindOneUrl = (id: string,) => {


  

  return `/projects/${id}`
}

export const projectsControllerFindOne = async (id: string, options?: RequestInit): Promise<projectsControllerFindOneResponse> => {
  
  return customInstance<projectsControllerFindOneResponse>(getProjectsControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getProjectsControllerFindOneQueryKey = (id: string,) => {
    return [
    `/projects/${id}`
    ] as const;
    }

    
export const getProjectsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof projectsControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsControllerFindOne>>> = ({ signal }) => projectsControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof projectsControllerFindOne>>>
export type ProjectsControllerFindOneQueryError = unknown


export function useProjectsControllerFindOne<TData = Awaited<ReturnType<typeof projectsControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFindOne<TData = Awaited<ReturnType<typeof projectsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof projectsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsControllerFindOne<TData = Awaited<ReturnType<typeof projectsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a project by ID
 */

export function useProjectsControllerFindOne<TData = Awaited<ReturnType<typeof projectsControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a project
 */
export type projectsControllerUpdateResponse200 = {
  data: ProjectDto
  status: 200
}
    
export type projectsControllerUpdateResponseSuccess = (projectsControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type projectsControllerUpdateResponse = (projectsControllerUpdateResponseSuccess)

export const getProjectsControllerUpdateUrl = (id: string,) => {


  

  return `/projects/${id}`
}

export const projectsControllerUpdate = async (id: string,
    updateProjectDto: UpdateProjectDto, options?: RequestInit): Promise<projectsControllerUpdateResponse> => {
  
  return customInstance<projectsControllerUpdateResponse>(getProjectsControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProjectDto,)
  }
);}




export const getProjectsControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUpdate>>, TError,{id: string;data: UpdateProjectDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUpdate>>, TError,{id: string;data: UpdateProjectDto}, TContext> => {

const mutationKey = ['projectsControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerUpdate>>, {id: string;data: UpdateProjectDto}> = (props) => {
          const {id,data} = props ?? {};

          return  projectsControllerUpdate(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerUpdate>>>
    export type ProjectsControllerUpdateMutationBody = UpdateProjectDto
    export type ProjectsControllerUpdateMutationError = unknown

    /**
 * @summary Update a project
 */
export const useProjectsControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerUpdate>>, TError,{id: string;data: UpdateProjectDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerUpdate>>,
        TError,
        {id: string;data: UpdateProjectDto},
        TContext
      > => {
      return useMutation(getProjectsControllerUpdateMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete a project
 */
export type projectsControllerDeleteResponse200 = {
  data: ProjectDto
  status: 200
}
    
export type projectsControllerDeleteResponseSuccess = (projectsControllerDeleteResponse200) & {
  headers: Headers;
};
;

export type projectsControllerDeleteResponse = (projectsControllerDeleteResponseSuccess)

export const getProjectsControllerDeleteUrl = (id: string,) => {


  

  return `/projects/${id}`
}

export const projectsControllerDelete = async (id: string, options?: RequestInit): Promise<projectsControllerDeleteResponse> => {
  
  return customInstance<projectsControllerDeleteResponse>(getProjectsControllerDeleteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getProjectsControllerDeleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['projectsControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  projectsControllerDelete(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof projectsControllerDelete>>>
    
    export type ProjectsControllerDeleteMutationError = unknown

    /**
 * @summary Delete a project
 */
export const useProjectsControllerDelete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getProjectsControllerDeleteMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create a new persona for a project
 */
export type personasControllerCreateResponse201 = {
  data: PersonaResponseDto
  status: 201
}
    
export type personasControllerCreateResponseSuccess = (personasControllerCreateResponse201) & {
  headers: Headers;
};
;

export type personasControllerCreateResponse = (personasControllerCreateResponseSuccess)

export const getPersonasControllerCreateUrl = (projectId: string,) => {


  

  return `/projects/${projectId}/personas`
}

export const personasControllerCreate = async (projectId: string,
    createPersonaDto: CreatePersonaDto, options?: RequestInit): Promise<personasControllerCreateResponse> => {
  
  return customInstance<personasControllerCreateResponse>(getPersonasControllerCreateUrl(projectId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPersonaDto,)
  }
);}




export const getPersonasControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerCreate>>, TError,{projectId: string;data: CreatePersonaDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof personasControllerCreate>>, TError,{projectId: string;data: CreatePersonaDto}, TContext> => {

const mutationKey = ['personasControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personasControllerCreate>>, {projectId: string;data: CreatePersonaDto}> = (props) => {
          const {projectId,data} = props ?? {};

          return  personasControllerCreate(projectId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PersonasControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof personasControllerCreate>>>
    export type PersonasControllerCreateMutationBody = CreatePersonaDto
    export type PersonasControllerCreateMutationError = unknown

    /**
 * @summary Create a new persona for a project
 */
export const usePersonasControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerCreate>>, TError,{projectId: string;data: CreatePersonaDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof personasControllerCreate>>,
        TError,
        {projectId: string;data: CreatePersonaDto},
        TContext
      > => {
      return useMutation(getPersonasControllerCreateMutationOptions(options), queryClient);
    }
    
/**
 * @summary List all personas for a project
 */
export type personasControllerFindAllByProjectResponse200 = {
  data: PersonaResponseDto[]
  status: 200
}
    
export type personasControllerFindAllByProjectResponseSuccess = (personasControllerFindAllByProjectResponse200) & {
  headers: Headers;
};
;

export type personasControllerFindAllByProjectResponse = (personasControllerFindAllByProjectResponseSuccess)

export const getPersonasControllerFindAllByProjectUrl = (projectId: string,) => {


  

  return `/projects/${projectId}/personas`
}

export const personasControllerFindAllByProject = async (projectId: string, options?: RequestInit): Promise<personasControllerFindAllByProjectResponse> => {
  
  return customInstance<personasControllerFindAllByProjectResponse>(getPersonasControllerFindAllByProjectUrl(projectId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPersonasControllerFindAllByProjectQueryKey = (projectId: string,) => {
    return [
    `/projects/${projectId}/personas`
    ] as const;
    }

    
export const getPersonasControllerFindAllByProjectQueryOptions = <TData = Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError = unknown>(projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonasControllerFindAllByProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personasControllerFindAllByProject>>> = ({ signal }) => personasControllerFindAllByProject(projectId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonasControllerFindAllByProjectQueryResult = NonNullable<Awaited<ReturnType<typeof personasControllerFindAllByProject>>>
export type PersonasControllerFindAllByProjectQueryError = unknown


export function usePersonasControllerFindAllByProject<TData = Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof personasControllerFindAllByProject>>,
          TError,
          Awaited<ReturnType<typeof personasControllerFindAllByProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonasControllerFindAllByProject<TData = Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof personasControllerFindAllByProject>>,
          TError,
          Awaited<ReturnType<typeof personasControllerFindAllByProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonasControllerFindAllByProject<TData = Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all personas for a project
 */

export function usePersonasControllerFindAllByProject<TData = Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonasControllerFindAllByProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get a persona by ID
 */
export type personasControllerFindOneResponse200 = {
  data: PersonaResponseDto
  status: 200
}
    
export type personasControllerFindOneResponseSuccess = (personasControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type personasControllerFindOneResponse = (personasControllerFindOneResponseSuccess)

export const getPersonasControllerFindOneUrl = (id: string,) => {


  

  return `/personas/${id}`
}

export const personasControllerFindOne = async (id: string, options?: RequestInit): Promise<personasControllerFindOneResponse> => {
  
  return customInstance<personasControllerFindOneResponse>(getPersonasControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPersonasControllerFindOneQueryKey = (id: string,) => {
    return [
    `/personas/${id}`
    ] as const;
    }

    
export const getPersonasControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof personasControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonasControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personasControllerFindOne>>> = ({ signal }) => personasControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonasControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof personasControllerFindOne>>>
export type PersonasControllerFindOneQueryError = unknown


export function usePersonasControllerFindOne<TData = Awaited<ReturnType<typeof personasControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof personasControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof personasControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonasControllerFindOne<TData = Awaited<ReturnType<typeof personasControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof personasControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof personasControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonasControllerFindOne<TData = Awaited<ReturnType<typeof personasControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a persona by ID
 */

export function usePersonasControllerFindOne<TData = Awaited<ReturnType<typeof personasControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personasControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonasControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a persona
 */
export type personasControllerUpdateResponse200 = {
  data: PersonaResponseDto
  status: 200
}
    
export type personasControllerUpdateResponseSuccess = (personasControllerUpdateResponse200) & {
  headers: Headers;
};
;

export type personasControllerUpdateResponse = (personasControllerUpdateResponseSuccess)

export const getPersonasControllerUpdateUrl = (id: string,) => {


  

  return `/personas/${id}`
}

export const personasControllerUpdate = async (id: string,
    updatePersonaDto: UpdatePersonaDto, options?: RequestInit): Promise<personasControllerUpdateResponse> => {
  
  return customInstance<personasControllerUpdateResponse>(getPersonasControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePersonaDto,)
  }
);}




export const getPersonasControllerUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerUpdate>>, TError,{id: string;data: UpdatePersonaDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof personasControllerUpdate>>, TError,{id: string;data: UpdatePersonaDto}, TContext> => {

const mutationKey = ['personasControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personasControllerUpdate>>, {id: string;data: UpdatePersonaDto}> = (props) => {
          const {id,data} = props ?? {};

          return  personasControllerUpdate(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PersonasControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof personasControllerUpdate>>>
    export type PersonasControllerUpdateMutationBody = UpdatePersonaDto
    export type PersonasControllerUpdateMutationError = unknown

    /**
 * @summary Update a persona
 */
export const usePersonasControllerUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerUpdate>>, TError,{id: string;data: UpdatePersonaDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof personasControllerUpdate>>,
        TError,
        {id: string;data: UpdatePersonaDto},
        TContext
      > => {
      return useMutation(getPersonasControllerUpdateMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete a persona
 */
export type personasControllerDeleteResponse200 = {
  data: PersonaResponseDto
  status: 200
}
    
export type personasControllerDeleteResponseSuccess = (personasControllerDeleteResponse200) & {
  headers: Headers;
};
;

export type personasControllerDeleteResponse = (personasControllerDeleteResponseSuccess)

export const getPersonasControllerDeleteUrl = (id: string,) => {


  

  return `/personas/${id}`
}

export const personasControllerDelete = async (id: string, options?: RequestInit): Promise<personasControllerDeleteResponse> => {
  
  return customInstance<personasControllerDeleteResponse>(getPersonasControllerDeleteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getPersonasControllerDeleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof personasControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['personasControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personasControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  personasControllerDelete(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PersonasControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof personasControllerDelete>>>
    
    export type PersonasControllerDeleteMutationError = unknown

    /**
 * @summary Delete a persona
 */
export const usePersonasControllerDelete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personasControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof personasControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getPersonasControllerDeleteMutationOptions(options), queryClient);
    }

/**
 * @summary Generate a persona suggestion using AI
 */
export interface GeneratePersonaDto {
  prompt: string;
  productName?: string;
  productDescription?: string;
}

export interface GeneratedPersonaDto {
  name: string;
  description: string;
  demographics?: string;
  painPoints: string[];
  desires: string[];
  objections: string[];
}

export type personasControllerGenerateResponse201 = {
  data: GeneratedPersonaDto;
  status: 201;
};

export type personasControllerGenerateResponseSuccess = personasControllerGenerateResponse201 & {
  headers: Headers;
};

export type personasControllerGenerateResponse = personasControllerGenerateResponseSuccess;

export const getPersonasControllerGenerateUrl = (projectId: string) => {
  return `/projects/${projectId}/personas/generate`;
};

export const personasControllerGenerate = async (
  projectId: string,
  generatePersonaDto: GeneratePersonaDto,
  options?: RequestInit
): Promise<personasControllerGenerateResponse> => {
  return customInstance<personasControllerGenerateResponse>(
    getPersonasControllerGenerateUrl(projectId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(generatePersonaDto),
    }
  );
};

/**
 * @summary Get recent scripts across all projects
 */
export type batchesControllerGetRecentScriptsResponse200 = {
  data: RecentScriptDto[]
  status: 200
}
    
export type batchesControllerGetRecentScriptsResponseSuccess = (batchesControllerGetRecentScriptsResponse200) & {
  headers: Headers;
};
;

export type batchesControllerGetRecentScriptsResponse = (batchesControllerGetRecentScriptsResponseSuccess)

export const getBatchesControllerGetRecentScriptsUrl = () => {


  

  return `/scripts/recent`
}

export const batchesControllerGetRecentScripts = async ( options?: RequestInit): Promise<batchesControllerGetRecentScriptsResponse> => {
  
  return customInstance<batchesControllerGetRecentScriptsResponse>(getBatchesControllerGetRecentScriptsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBatchesControllerGetRecentScriptsQueryKey = () => {
    return [
    `/scripts/recent`
    ] as const;
    }

    
export const getBatchesControllerGetRecentScriptsQueryOptions = <TData = Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBatchesControllerGetRecentScriptsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>> = ({ signal }) => batchesControllerGetRecentScripts({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BatchesControllerGetRecentScriptsQueryResult = NonNullable<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>>
export type BatchesControllerGetRecentScriptsQueryError = unknown


export function useBatchesControllerGetRecentScripts<TData = Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerGetRecentScripts<TData = Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerGetRecentScripts<TData = Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get recent scripts across all projects
 */

export function useBatchesControllerGetRecentScripts<TData = Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetRecentScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBatchesControllerGetRecentScriptsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new batch for script generation
 */
export type batchesControllerCreateResponse201 = {
  data: BatchDto
  status: 201
}
    
export type batchesControllerCreateResponseSuccess = (batchesControllerCreateResponse201) & {
  headers: Headers;
};
;

export type batchesControllerCreateResponse = (batchesControllerCreateResponseSuccess)

export const getBatchesControllerCreateUrl = (projectId: string,) => {


  

  return `/projects/${projectId}/batches`
}

export const batchesControllerCreate = async (projectId: string,
    createBatchDto: CreateBatchDto, options?: RequestInit): Promise<batchesControllerCreateResponse> => {
  
  return customInstance<batchesControllerCreateResponse>(getBatchesControllerCreateUrl(projectId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBatchDto,)
  }
);}




export const getBatchesControllerCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchesControllerCreate>>, TError,{projectId: string;data: CreateBatchDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof batchesControllerCreate>>, TError,{projectId: string;data: CreateBatchDto}, TContext> => {

const mutationKey = ['batchesControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchesControllerCreate>>, {projectId: string;data: CreateBatchDto}> = (props) => {
          const {projectId,data} = props ?? {};

          return  batchesControllerCreate(projectId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BatchesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof batchesControllerCreate>>>
    export type BatchesControllerCreateMutationBody = CreateBatchDto
    export type BatchesControllerCreateMutationError = unknown

    /**
 * @summary Create a new batch for script generation
 */
export const useBatchesControllerCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchesControllerCreate>>, TError,{projectId: string;data: CreateBatchDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchesControllerCreate>>,
        TError,
        {projectId: string;data: CreateBatchDto},
        TContext
      > => {
      return useMutation(getBatchesControllerCreateMutationOptions(options), queryClient);
    }
    
/**
 * @summary List all batches for a project
 */
export type batchesControllerFindAllByProjectResponse200 = {
  data: BatchDto[]
  status: 200
}
    
export type batchesControllerFindAllByProjectResponseSuccess = (batchesControllerFindAllByProjectResponse200) & {
  headers: Headers;
};
;

export type batchesControllerFindAllByProjectResponse = (batchesControllerFindAllByProjectResponseSuccess)

export const getBatchesControllerFindAllByProjectUrl = (projectId: string,) => {


  

  return `/projects/${projectId}/batches`
}

export const batchesControllerFindAllByProject = async (projectId: string, options?: RequestInit): Promise<batchesControllerFindAllByProjectResponse> => {
  
  return customInstance<batchesControllerFindAllByProjectResponse>(getBatchesControllerFindAllByProjectUrl(projectId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBatchesControllerFindAllByProjectQueryKey = (projectId: string,) => {
    return [
    `/projects/${projectId}/batches`
    ] as const;
    }

    
export const getBatchesControllerFindAllByProjectQueryOptions = <TData = Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError = unknown>(projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBatchesControllerFindAllByProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>> = ({ signal }) => batchesControllerFindAllByProject(projectId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BatchesControllerFindAllByProjectQueryResult = NonNullable<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>>
export type BatchesControllerFindAllByProjectQueryError = unknown


export function useBatchesControllerFindAllByProject<TData = Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerFindAllByProject>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerFindAllByProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerFindAllByProject<TData = Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerFindAllByProject>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerFindAllByProject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerFindAllByProject<TData = Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all batches for a project
 */

export function useBatchesControllerFindAllByProject<TData = Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError = unknown>(
 projectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindAllByProject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBatchesControllerFindAllByProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get a batch by ID
 */
export type batchesControllerFindOneResponse200 = {
  data: BatchDto
  status: 200
}
    
export type batchesControllerFindOneResponseSuccess = (batchesControllerFindOneResponse200) & {
  headers: Headers;
};
;

export type batchesControllerFindOneResponse = (batchesControllerFindOneResponseSuccess)

export const getBatchesControllerFindOneUrl = (id: string,) => {


  

  return `/batches/${id}`
}

export const batchesControllerFindOne = async (id: string, options?: RequestInit): Promise<batchesControllerFindOneResponse> => {
  
  return customInstance<batchesControllerFindOneResponse>(getBatchesControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBatchesControllerFindOneQueryKey = (id: string,) => {
    return [
    `/batches/${id}`
    ] as const;
    }

    
export const getBatchesControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof batchesControllerFindOne>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBatchesControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof batchesControllerFindOne>>> = ({ signal }) => batchesControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BatchesControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof batchesControllerFindOne>>>
export type BatchesControllerFindOneQueryError = unknown


export function useBatchesControllerFindOne<TData = Awaited<ReturnType<typeof batchesControllerFindOne>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerFindOne<TData = Awaited<ReturnType<typeof batchesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerFindOne<TData = Awaited<ReturnType<typeof batchesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a batch by ID
 */

export function useBatchesControllerFindOne<TData = Awaited<ReturnType<typeof batchesControllerFindOne>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBatchesControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get all scripts for a batch
 */
export type batchesControllerGetScriptsResponse200 = {
  data: ScriptDto[]
  status: 200
}
    
export type batchesControllerGetScriptsResponseSuccess = (batchesControllerGetScriptsResponse200) & {
  headers: Headers;
};
;

export type batchesControllerGetScriptsResponse = (batchesControllerGetScriptsResponseSuccess)

export const getBatchesControllerGetScriptsUrl = (id: string,) => {


  

  return `/batches/${id}/scripts`
}

export const batchesControllerGetScripts = async (id: string, options?: RequestInit): Promise<batchesControllerGetScriptsResponse> => {
  
  return customInstance<batchesControllerGetScriptsResponse>(getBatchesControllerGetScriptsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBatchesControllerGetScriptsQueryKey = (id: string,) => {
    return [
    `/batches/${id}/scripts`
    ] as const;
    }

    
export const getBatchesControllerGetScriptsQueryOptions = <TData = Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBatchesControllerGetScriptsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof batchesControllerGetScripts>>> = ({ signal }) => batchesControllerGetScripts(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BatchesControllerGetScriptsQueryResult = NonNullable<Awaited<ReturnType<typeof batchesControllerGetScripts>>>
export type BatchesControllerGetScriptsQueryError = unknown


export function useBatchesControllerGetScripts<TData = Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerGetScripts>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerGetScripts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerGetScripts<TData = Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof batchesControllerGetScripts>>,
          TError,
          Awaited<ReturnType<typeof batchesControllerGetScripts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBatchesControllerGetScripts<TData = Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all scripts for a batch
 */

export function useBatchesControllerGetScripts<TData = Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof batchesControllerGetScripts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBatchesControllerGetScriptsQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Regenerate a script with new instructions
 */
export type batchesControllerRegenerateScriptResponse201 = {
  data: ScriptDto
  status: 201
}
    
export type batchesControllerRegenerateScriptResponseSuccess = (batchesControllerRegenerateScriptResponse201) & {
  headers: Headers;
};
;

export type batchesControllerRegenerateScriptResponse = (batchesControllerRegenerateScriptResponseSuccess)

export const getBatchesControllerRegenerateScriptUrl = (id: string,) => {


  

  return `/scripts/${id}/regenerate`
}

export const batchesControllerRegenerateScript = async (id: string,
    regenerateDto: RegenerateDto, options?: RequestInit): Promise<batchesControllerRegenerateScriptResponse> => {
  
  return customInstance<batchesControllerRegenerateScriptResponse>(getBatchesControllerRegenerateScriptUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      regenerateDto,)
  }
);}




export const getBatchesControllerRegenerateScriptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchesControllerRegenerateScript>>, TError,{id: string;data: RegenerateDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof batchesControllerRegenerateScript>>, TError,{id: string;data: RegenerateDto}, TContext> => {

const mutationKey = ['batchesControllerRegenerateScript'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchesControllerRegenerateScript>>, {id: string;data: RegenerateDto}> = (props) => {
          const {id,data} = props ?? {};

          return  batchesControllerRegenerateScript(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BatchesControllerRegenerateScriptMutationResult = NonNullable<Awaited<ReturnType<typeof batchesControllerRegenerateScript>>>
    export type BatchesControllerRegenerateScriptMutationBody = RegenerateDto
    export type BatchesControllerRegenerateScriptMutationError = unknown

    /**
 * @summary Regenerate a script with new instructions
 */
export const useBatchesControllerRegenerateScript = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchesControllerRegenerateScript>>, TError,{id: string;data: RegenerateDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchesControllerRegenerateScript>>,
        TError,
        {id: string;data: RegenerateDto},
        TContext
      > => {
      return useMutation(getBatchesControllerRegenerateScriptMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get current credit balances
 */
export type creditsControllerGetBalancesResponse200 = {
  data: CreditsBalancesResponseDto
  status: 200
}
    
export type creditsControllerGetBalancesResponseSuccess = (creditsControllerGetBalancesResponse200) & {
  headers: Headers;
};
;

export type creditsControllerGetBalancesResponse = (creditsControllerGetBalancesResponseSuccess)

export const getCreditsControllerGetBalancesUrl = () => {


  

  return `/credits/balances`
}

export const creditsControllerGetBalances = async ( options?: RequestInit): Promise<creditsControllerGetBalancesResponse> => {
  
  return customInstance<creditsControllerGetBalancesResponse>(getCreditsControllerGetBalancesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getCreditsControllerGetBalancesQueryKey = () => {
    return [
    `/credits/balances`
    ] as const;
    }

    
export const getCreditsControllerGetBalancesQueryOptions = <TData = Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCreditsControllerGetBalancesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creditsControllerGetBalances>>> = ({ signal }) => creditsControllerGetBalances({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreditsControllerGetBalancesQueryResult = NonNullable<Awaited<ReturnType<typeof creditsControllerGetBalances>>>
export type CreditsControllerGetBalancesQueryError = unknown


export function useCreditsControllerGetBalances<TData = Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof creditsControllerGetBalances>>,
          TError,
          Awaited<ReturnType<typeof creditsControllerGetBalances>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreditsControllerGetBalances<TData = Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof creditsControllerGetBalances>>,
          TError,
          Awaited<ReturnType<typeof creditsControllerGetBalances>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreditsControllerGetBalances<TData = Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current credit balances
 */

export function useCreditsControllerGetBalances<TData = Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetBalances>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreditsControllerGetBalancesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get credit transaction history
 */
export type creditsControllerGetTransactionsResponse200 = {
  data: CreditTransactionDto[]
  status: 200
}
    
export type creditsControllerGetTransactionsResponseSuccess = (creditsControllerGetTransactionsResponse200) & {
  headers: Headers;
};
;

export type creditsControllerGetTransactionsResponse = (creditsControllerGetTransactionsResponseSuccess)

export const getCreditsControllerGetTransactionsUrl = () => {


  

  return `/credits/transactions`
}

export const creditsControllerGetTransactions = async ( options?: RequestInit): Promise<creditsControllerGetTransactionsResponse> => {
  
  return customInstance<creditsControllerGetTransactionsResponse>(getCreditsControllerGetTransactionsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getCreditsControllerGetTransactionsQueryKey = () => {
    return [
    `/credits/transactions`
    ] as const;
    }

    
export const getCreditsControllerGetTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCreditsControllerGetTransactionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creditsControllerGetTransactions>>> = ({ signal }) => creditsControllerGetTransactions({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreditsControllerGetTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof creditsControllerGetTransactions>>>
export type CreditsControllerGetTransactionsQueryError = unknown


export function useCreditsControllerGetTransactions<TData = Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof creditsControllerGetTransactions>>,
          TError,
          Awaited<ReturnType<typeof creditsControllerGetTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreditsControllerGetTransactions<TData = Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof creditsControllerGetTransactions>>,
          TError,
          Awaited<ReturnType<typeof creditsControllerGetTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreditsControllerGetTransactions<TData = Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get credit transaction history
 */

export function useCreditsControllerGetTransactions<TData = Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creditsControllerGetTransactions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreditsControllerGetTransactionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Export batch scripts to PDF and CSV
 */
export type exportsControllerExportBatchResponse201 = {
  data: ExportResultDto
  status: 201
}
    
export type exportsControllerExportBatchResponseSuccess = (exportsControllerExportBatchResponse201) & {
  headers: Headers;
};
;

export type exportsControllerExportBatchResponse = (exportsControllerExportBatchResponseSuccess)

export const getExportsControllerExportBatchUrl = (id: string,) => {


  

  return `/batches/${id}/export`
}

export const exportsControllerExportBatch = async (id: string, options?: RequestInit): Promise<exportsControllerExportBatchResponse> => {
  
  return customInstance<exportsControllerExportBatchResponse>(getExportsControllerExportBatchUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getExportsControllerExportBatchMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exportsControllerExportBatch>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof exportsControllerExportBatch>>, TError,{id: string}, TContext> => {

const mutationKey = ['exportsControllerExportBatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof exportsControllerExportBatch>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  exportsControllerExportBatch(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ExportsControllerExportBatchMutationResult = NonNullable<Awaited<ReturnType<typeof exportsControllerExportBatch>>>
    
    export type ExportsControllerExportBatchMutationError = unknown

    /**
 * @summary Export batch scripts to PDF and CSV
 */
export const useExportsControllerExportBatch = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exportsControllerExportBatch>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof exportsControllerExportBatch>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getExportsControllerExportBatchMutationOptions(options), queryClient);
    }
    
export type adminControllerGetStatsResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerGetStatsResponseSuccess = (adminControllerGetStatsResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetStatsResponse = (adminControllerGetStatsResponseSuccess)

export const getAdminControllerGetStatsUrl = () => {


  

  return `/admin/stats`
}

export const adminControllerGetStats = async ( options?: RequestInit): Promise<adminControllerGetStatsResponse> => {
  
  return customInstance<adminControllerGetStatsResponse>(getAdminControllerGetStatsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetStatsQueryKey = () => {
    return [
    `/admin/stats`
    ] as const;
    }

    
export const getAdminControllerGetStatsQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetStats>>> = ({ signal }) => adminControllerGetStats({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetStatsQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetStats>>>
export type AdminControllerGetStatsQueryError = unknown


export function useAdminControllerGetStats<TData = Awaited<ReturnType<typeof adminControllerGetStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetStats>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetStats<TData = Awaited<ReturnType<typeof adminControllerGetStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetStats>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetStats<TData = Awaited<ReturnType<typeof adminControllerGetStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetStats<TData = Awaited<ReturnType<typeof adminControllerGetStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerGetRequestsResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerGetRequestsResponseSuccess = (adminControllerGetRequestsResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetRequestsResponse = (adminControllerGetRequestsResponseSuccess)

export const getAdminControllerGetRequestsUrl = (params?: AdminControllerGetRequestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/admin/requests?${stringifiedParams}` : `/admin/requests`
}

export const adminControllerGetRequests = async (params?: AdminControllerGetRequestsParams, options?: RequestInit): Promise<adminControllerGetRequestsResponse> => {
  
  return customInstance<adminControllerGetRequestsResponse>(getAdminControllerGetRequestsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetRequestsQueryKey = (params?: AdminControllerGetRequestsParams,) => {
    return [
    `/admin/requests`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getAdminControllerGetRequestsQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetRequests>>, TError = unknown>(params?: AdminControllerGetRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetRequests>>> = ({ signal }) => adminControllerGetRequests(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetRequests>>>
export type AdminControllerGetRequestsQueryError = unknown


export function useAdminControllerGetRequests<TData = Awaited<ReturnType<typeof adminControllerGetRequests>>, TError = unknown>(
 params: undefined |  AdminControllerGetRequestsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetRequests>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetRequests<TData = Awaited<ReturnType<typeof adminControllerGetRequests>>, TError = unknown>(
 params?: AdminControllerGetRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetRequests>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetRequests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetRequests<TData = Awaited<ReturnType<typeof adminControllerGetRequests>>, TError = unknown>(
 params?: AdminControllerGetRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetRequests<TData = Awaited<ReturnType<typeof adminControllerGetRequests>>, TError = unknown>(
 params?: AdminControllerGetRequestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetRequests>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerApproveRequestResponse201 = {
  data: AdminControllerApproveRequest201
  status: 201
}
    
export type adminControllerApproveRequestResponseSuccess = (adminControllerApproveRequestResponse201) & {
  headers: Headers;
};
;

export type adminControllerApproveRequestResponse = (adminControllerApproveRequestResponseSuccess)

export const getAdminControllerApproveRequestUrl = (id: string,) => {


  

  return `/admin/requests/${id}/approve`
}

export const adminControllerApproveRequest = async (id: string, options?: RequestInit): Promise<adminControllerApproveRequestResponse> => {
  
  return customInstance<adminControllerApproveRequestResponse>(getAdminControllerApproveRequestUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerApproveRequestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerApproveRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerApproveRequest>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerApproveRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerApproveRequest>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerApproveRequest(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerApproveRequestMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerApproveRequest>>>
    
    export type AdminControllerApproveRequestMutationError = unknown

    export const useAdminControllerApproveRequest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerApproveRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerApproveRequest>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerApproveRequestMutationOptions(options), queryClient);
    }
    
export type adminControllerRejectRequestResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerRejectRequestResponseSuccess = (adminControllerRejectRequestResponse201) & {
  headers: Headers;
};
;

export type adminControllerRejectRequestResponse = (adminControllerRejectRequestResponseSuccess)

export const getAdminControllerRejectRequestUrl = (id: string,) => {


  

  return `/admin/requests/${id}/reject`
}

export const adminControllerRejectRequest = async (id: string, options?: RequestInit): Promise<adminControllerRejectRequestResponse> => {
  
  return customInstance<adminControllerRejectRequestResponse>(getAdminControllerRejectRequestUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerRejectRequestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerRejectRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerRejectRequest>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerRejectRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerRejectRequest>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerRejectRequest(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerRejectRequestMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerRejectRequest>>>
    
    export type AdminControllerRejectRequestMutationError = unknown

    export const useAdminControllerRejectRequest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerRejectRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerRejectRequest>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerRejectRequestMutationOptions(options), queryClient);
    }
    
export type adminControllerDeleteRequestResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerDeleteRequestResponseSuccess = (adminControllerDeleteRequestResponse200) & {
  headers: Headers;
};
;

export type adminControllerDeleteRequestResponse = (adminControllerDeleteRequestResponseSuccess)

export const getAdminControllerDeleteRequestUrl = (id: string,) => {


  

  return `/admin/requests/${id}`
}

export const adminControllerDeleteRequest = async (id: string, options?: RequestInit): Promise<adminControllerDeleteRequestResponse> => {
  
  return customInstance<adminControllerDeleteRequestResponse>(getAdminControllerDeleteRequestUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getAdminControllerDeleteRequestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteRequest>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerDeleteRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerDeleteRequest>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerDeleteRequest(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerDeleteRequestMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerDeleteRequest>>>
    
    export type AdminControllerDeleteRequestMutationError = unknown

    export const useAdminControllerDeleteRequest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteRequest>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerDeleteRequest>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerDeleteRequestMutationOptions(options), queryClient);
    }
    
export type adminControllerGetUsersResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerGetUsersResponseSuccess = (adminControllerGetUsersResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetUsersResponse = (adminControllerGetUsersResponseSuccess)

export const getAdminControllerGetUsersUrl = () => {


  

  return `/admin/users`
}

export const adminControllerGetUsers = async ( options?: RequestInit): Promise<adminControllerGetUsersResponse> => {
  
  return customInstance<adminControllerGetUsersResponse>(getAdminControllerGetUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetUsersQueryKey = () => {
    return [
    `/admin/users`
    ] as const;
    }

    
export const getAdminControllerGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetUsers>>> = ({ signal }) => adminControllerGetUsers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetUsers>>>
export type AdminControllerGetUsersQueryError = unknown


export function useAdminControllerGetUsers<TData = Awaited<ReturnType<typeof adminControllerGetUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetUsers>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetUsers<TData = Awaited<ReturnType<typeof adminControllerGetUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetUsers>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetUsers<TData = Awaited<ReturnType<typeof adminControllerGetUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetUsers<TData = Awaited<ReturnType<typeof adminControllerGetUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerCreateUserResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerCreateUserResponseSuccess = (adminControllerCreateUserResponse201) & {
  headers: Headers;
};
;

export type adminControllerCreateUserResponse = (adminControllerCreateUserResponseSuccess)

export const getAdminControllerCreateUserUrl = () => {


  

  return `/admin/users`
}

export const adminControllerCreateUser = async ( options?: RequestInit): Promise<adminControllerCreateUserResponse> => {
  
  return customInstance<adminControllerCreateUserResponse>(getAdminControllerCreateUserUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateUser>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateUser>>, TError,void, TContext> => {

const mutationKey = ['adminControllerCreateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerCreateUser>>, void> = () => {
          

          return  adminControllerCreateUser(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerCreateUser>>>
    
    export type AdminControllerCreateUserMutationError = unknown

    export const useAdminControllerCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateUser>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerCreateUser>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAdminControllerCreateUserMutationOptions(options), queryClient);
    }
    
export type adminControllerDeleteUserResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerDeleteUserResponseSuccess = (adminControllerDeleteUserResponse200) & {
  headers: Headers;
};
;

export type adminControllerDeleteUserResponse = (adminControllerDeleteUserResponseSuccess)

export const getAdminControllerDeleteUserUrl = (id: string,) => {


  

  return `/admin/users/${id}`
}

export const adminControllerDeleteUser = async (id: string, options?: RequestInit): Promise<adminControllerDeleteUserResponse> => {
  
  return customInstance<adminControllerDeleteUserResponse>(getAdminControllerDeleteUserUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getAdminControllerDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerDeleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerDeleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerDeleteUser(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerDeleteUser>>>
    
    export type AdminControllerDeleteUserMutationError = unknown

    export const useAdminControllerDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerDeleteUser>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerDeleteUserMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get user details with credits
 */
export type adminControllerGetUserDetailResponse200 = {
  data: AdminUserDetailDto
  status: 200
}
    
export type adminControllerGetUserDetailResponseSuccess = (adminControllerGetUserDetailResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetUserDetailResponse = (adminControllerGetUserDetailResponseSuccess)

export const getAdminControllerGetUserDetailUrl = (id: string,) => {


  

  return `/admin/users/${id}`
}

export const adminControllerGetUserDetail = async (id: string, options?: RequestInit): Promise<adminControllerGetUserDetailResponse> => {
  
  return customInstance<adminControllerGetUserDetailResponse>(getAdminControllerGetUserDetailUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetUserDetailQueryKey = (id: string,) => {
    return [
    `/admin/users/${id}`
    ] as const;
    }

    
export const getAdminControllerGetUserDetailQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetUserDetailQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetUserDetail>>> = ({ signal }) => adminControllerGetUserDetail(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetUserDetailQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetUserDetail>>>
export type AdminControllerGetUserDetailQueryError = unknown


export function useAdminControllerGetUserDetail<TData = Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetUserDetail>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetUserDetail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetUserDetail<TData = Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetUserDetail>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetUserDetail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetUserDetail<TData = Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user details with credits
 */

export function useAdminControllerGetUserDetail<TData = Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetUserDetail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetUserDetailQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerToggleAdminResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerToggleAdminResponseSuccess = (adminControllerToggleAdminResponse201) & {
  headers: Headers;
};
;

export type adminControllerToggleAdminResponse = (adminControllerToggleAdminResponseSuccess)

export const getAdminControllerToggleAdminUrl = (id: string,) => {


  

  return `/admin/users/${id}/toggle-admin`
}

export const adminControllerToggleAdmin = async (id: string, options?: RequestInit): Promise<adminControllerToggleAdminResponse> => {
  
  return customInstance<adminControllerToggleAdminResponse>(getAdminControllerToggleAdminUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerToggleAdminMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerToggleAdmin>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerToggleAdmin>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerToggleAdmin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerToggleAdmin>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerToggleAdmin(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerToggleAdminMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerToggleAdmin>>>
    
    export type AdminControllerToggleAdminMutationError = unknown

    export const useAdminControllerToggleAdmin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerToggleAdmin>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerToggleAdmin>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerToggleAdminMutationOptions(options), queryClient);
    }
    
export type adminControllerGenerateMagicLinkResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerGenerateMagicLinkResponseSuccess = (adminControllerGenerateMagicLinkResponse201) & {
  headers: Headers;
};
;

export type adminControllerGenerateMagicLinkResponse = (adminControllerGenerateMagicLinkResponseSuccess)

export const getAdminControllerGenerateMagicLinkUrl = (id: string,) => {


  

  return `/admin/users/${id}/magic-link`
}

export const adminControllerGenerateMagicLink = async (id: string, options?: RequestInit): Promise<adminControllerGenerateMagicLinkResponse> => {
  
  return customInstance<adminControllerGenerateMagicLinkResponse>(getAdminControllerGenerateMagicLinkUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerGenerateMagicLinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerGenerateMagicLink'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerGenerateMagicLink(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerGenerateMagicLinkMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>>
    
    export type AdminControllerGenerateMagicLinkMutationError = unknown

    export const useAdminControllerGenerateMagicLink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerGenerateMagicLink>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerGenerateMagicLinkMutationOptions(options), queryClient);
    }
    
/**
 * @summary Update user plan
 */
export type adminControllerUpdateUserPlanResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerUpdateUserPlanResponseSuccess = (adminControllerUpdateUserPlanResponse200) & {
  headers: Headers;
};
;

export type adminControllerUpdateUserPlanResponse = (adminControllerUpdateUserPlanResponseSuccess)

export const getAdminControllerUpdateUserPlanUrl = (id: string,) => {


  

  return `/admin/users/${id}/plan`
}

export const adminControllerUpdateUserPlan = async (id: string,
    updateUserPlanDto: UpdateUserPlanDto, options?: RequestInit): Promise<adminControllerUpdateUserPlanResponse> => {
  
  return customInstance<adminControllerUpdateUserPlanResponse>(getAdminControllerUpdateUserPlanUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserPlanDto,)
  }
);}




export const getAdminControllerUpdateUserPlanMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>, TError,{id: string;data: UpdateUserPlanDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>, TError,{id: string;data: UpdateUserPlanDto}, TContext> => {

const mutationKey = ['adminControllerUpdateUserPlan'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>, {id: string;data: UpdateUserPlanDto}> = (props) => {
          const {id,data} = props ?? {};

          return  adminControllerUpdateUserPlan(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerUpdateUserPlanMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>>
    export type AdminControllerUpdateUserPlanMutationBody = UpdateUserPlanDto
    export type AdminControllerUpdateUserPlanMutationError = unknown

    /**
 * @summary Update user plan
 */
export const useAdminControllerUpdateUserPlan = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>, TError,{id: string;data: UpdateUserPlanDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerUpdateUserPlan>>,
        TError,
        {id: string;data: UpdateUserPlanDto},
        TContext
      > => {
      return useMutation(getAdminControllerUpdateUserPlanMutationOptions(options), queryClient);
    }
    
/**
 * @summary Grant credits to user
 */
export type adminControllerGrantCreditsResponse201 = {
  data: GrantCreditsResponseDto
  status: 201
}
    
export type adminControllerGrantCreditsResponseSuccess = (adminControllerGrantCreditsResponse201) & {
  headers: Headers;
};
;

export type adminControllerGrantCreditsResponse = (adminControllerGrantCreditsResponseSuccess)

export const getAdminControllerGrantCreditsUrl = (id: string,) => {


  

  return `/admin/users/${id}/credits`
}

export const adminControllerGrantCredits = async (id: string,
    grantCreditsDto: GrantCreditsDto, options?: RequestInit): Promise<adminControllerGrantCreditsResponse> => {
  
  return customInstance<adminControllerGrantCreditsResponse>(getAdminControllerGrantCreditsUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      grantCreditsDto,)
  }
);}




export const getAdminControllerGrantCreditsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerGrantCredits>>, TError,{id: string;data: GrantCreditsDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerGrantCredits>>, TError,{id: string;data: GrantCreditsDto}, TContext> => {

const mutationKey = ['adminControllerGrantCredits'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerGrantCredits>>, {id: string;data: GrantCreditsDto}> = (props) => {
          const {id,data} = props ?? {};

          return  adminControllerGrantCredits(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerGrantCreditsMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerGrantCredits>>>
    export type AdminControllerGrantCreditsMutationBody = GrantCreditsDto
    export type AdminControllerGrantCreditsMutationError = unknown

    /**
 * @summary Grant credits to user
 */
export const useAdminControllerGrantCredits = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerGrantCredits>>, TError,{id: string;data: GrantCreditsDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerGrantCredits>>,
        TError,
        {id: string;data: GrantCreditsDto},
        TContext
      > => {
      return useMutation(getAdminControllerGrantCreditsMutationOptions(options), queryClient);
    }
    
export type adminControllerGetQueueStatsResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerGetQueueStatsResponseSuccess = (adminControllerGetQueueStatsResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetQueueStatsResponse = (adminControllerGetQueueStatsResponseSuccess)

export const getAdminControllerGetQueueStatsUrl = () => {


  

  return `/admin/queue/stats`
}

export const adminControllerGetQueueStats = async ( options?: RequestInit): Promise<adminControllerGetQueueStatsResponse> => {
  
  return customInstance<adminControllerGetQueueStatsResponse>(getAdminControllerGetQueueStatsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetQueueStatsQueryKey = () => {
    return [
    `/admin/queue/stats`
    ] as const;
    }

    
export const getAdminControllerGetQueueStatsQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetQueueStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetQueueStats>>> = ({ signal }) => adminControllerGetQueueStats({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetQueueStatsQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetQueueStats>>>
export type AdminControllerGetQueueStatsQueryError = unknown


export function useAdminControllerGetQueueStats<TData = Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetQueueStats>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetQueueStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetQueueStats<TData = Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetQueueStats>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetQueueStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetQueueStats<TData = Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetQueueStats<TData = Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetQueueStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerGetQueueJobsResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerGetQueueJobsResponseSuccess = (adminControllerGetQueueJobsResponse200) & {
  headers: Headers;
};
;

export type adminControllerGetQueueJobsResponse = (adminControllerGetQueueJobsResponseSuccess)

export const getAdminControllerGetQueueJobsUrl = (params: AdminControllerGetQueueJobsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/admin/queue/jobs?${stringifiedParams}` : `/admin/queue/jobs`
}

export const adminControllerGetQueueJobs = async (params: AdminControllerGetQueueJobsParams, options?: RequestInit): Promise<adminControllerGetQueueJobsResponse> => {
  
  return customInstance<adminControllerGetQueueJobsResponse>(getAdminControllerGetQueueJobsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAdminControllerGetQueueJobsQueryKey = (params?: AdminControllerGetQueueJobsParams,) => {
    return [
    `/admin/queue/jobs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getAdminControllerGetQueueJobsQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError = unknown>(params: AdminControllerGetQueueJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetQueueJobsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>> = ({ signal }) => adminControllerGetQueueJobs(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetQueueJobsQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>>
export type AdminControllerGetQueueJobsQueryError = unknown


export function useAdminControllerGetQueueJobs<TData = Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError = unknown>(
 params: AdminControllerGetQueueJobsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetQueueJobs>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetQueueJobs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetQueueJobs<TData = Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError = unknown>(
 params: AdminControllerGetQueueJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetQueueJobs>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetQueueJobs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetQueueJobs<TData = Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError = unknown>(
 params: AdminControllerGetQueueJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetQueueJobs<TData = Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError = unknown>(
 params: AdminControllerGetQueueJobsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetQueueJobs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetQueueJobsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type adminControllerRetryJobResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerRetryJobResponseSuccess = (adminControllerRetryJobResponse201) & {
  headers: Headers;
};
;

export type adminControllerRetryJobResponse = (adminControllerRetryJobResponseSuccess)

export const getAdminControllerRetryJobUrl = (id: string,) => {


  

  return `/admin/queue/jobs/${id}/retry`
}

export const adminControllerRetryJob = async (id: string, options?: RequestInit): Promise<adminControllerRetryJobResponse> => {
  
  return customInstance<adminControllerRetryJobResponse>(getAdminControllerRetryJobUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAdminControllerRetryJobMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerRetryJob>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerRetryJob>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerRetryJob'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerRetryJob>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerRetryJob(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerRetryJobMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerRetryJob>>>
    
    export type AdminControllerRetryJobMutationError = unknown

    export const useAdminControllerRetryJob = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerRetryJob>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerRetryJob>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getAdminControllerRetryJobMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get the current user profile
 */
export type settingsControllerGetProfileResponse200 = {
  data: ProfileDto
  status: 200
}
    
export type settingsControllerGetProfileResponseSuccess = (settingsControllerGetProfileResponse200) & {
  headers: Headers;
};
;

export type settingsControllerGetProfileResponse = (settingsControllerGetProfileResponseSuccess)

export const getSettingsControllerGetProfileUrl = () => {


  

  return `/settings/profile`
}

export const settingsControllerGetProfile = async ( options?: RequestInit): Promise<settingsControllerGetProfileResponse> => {
  
  return customInstance<settingsControllerGetProfileResponse>(getSettingsControllerGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSettingsControllerGetProfileQueryKey = () => {
    return [
    `/settings/profile`
    ] as const;
    }

    
export const getSettingsControllerGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSettingsControllerGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof settingsControllerGetProfile>>> = ({ signal }) => settingsControllerGetProfile({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SettingsControllerGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof settingsControllerGetProfile>>>
export type SettingsControllerGetProfileQueryError = unknown


export function useSettingsControllerGetProfile<TData = Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerGetProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerGetProfile<TData = Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof settingsControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof settingsControllerGetProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSettingsControllerGetProfile<TData = Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current user profile
 */

export function useSettingsControllerGetProfile<TData = Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof settingsControllerGetProfile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSettingsControllerGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update the current user profile
 */
export type settingsControllerUpdateProfileResponse200 = {
  data: ProfileDto
  status: 200
}
    
export type settingsControllerUpdateProfileResponseSuccess = (settingsControllerUpdateProfileResponse200) & {
  headers: Headers;
};
;

export type settingsControllerUpdateProfileResponse = (settingsControllerUpdateProfileResponseSuccess)

export const getSettingsControllerUpdateProfileUrl = () => {


  

  return `/settings/profile`
}

export const settingsControllerUpdateProfile = async (updateProfileDto: UpdateProfileDto, options?: RequestInit): Promise<settingsControllerUpdateProfileResponse> => {
  
  return customInstance<settingsControllerUpdateProfileResponse>(getSettingsControllerUpdateProfileUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateProfileDto,)
  }
);}




export const getSettingsControllerUpdateProfileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdateProfile>>, TError,{data: UpdateProfileDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdateProfile>>, TError,{data: UpdateProfileDto}, TContext> => {

const mutationKey = ['settingsControllerUpdateProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof settingsControllerUpdateProfile>>, {data: UpdateProfileDto}> = (props) => {
          const {data} = props ?? {};

          return  settingsControllerUpdateProfile(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SettingsControllerUpdateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof settingsControllerUpdateProfile>>>
    export type SettingsControllerUpdateProfileMutationBody = UpdateProfileDto
    export type SettingsControllerUpdateProfileMutationError = unknown

    /**
 * @summary Update the current user profile
 */
export const useSettingsControllerUpdateProfile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerUpdateProfile>>, TError,{data: UpdateProfileDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof settingsControllerUpdateProfile>>,
        TError,
        {data: UpdateProfileDto},
        TContext
      > => {
      return useMutation(getSettingsControllerUpdateProfileMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete the current user account
 */
export type settingsControllerDeleteAccountResponse200 = {
  data: DeleteAccountResultDto
  status: 200
}
    
export type settingsControllerDeleteAccountResponseSuccess = (settingsControllerDeleteAccountResponse200) & {
  headers: Headers;
};
;

export type settingsControllerDeleteAccountResponse = (settingsControllerDeleteAccountResponseSuccess)

export const getSettingsControllerDeleteAccountUrl = () => {


  

  return `/settings/account`
}

export const settingsControllerDeleteAccount = async ( options?: RequestInit): Promise<settingsControllerDeleteAccountResponse> => {
  
  return customInstance<settingsControllerDeleteAccountResponse>(getSettingsControllerDeleteAccountUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getSettingsControllerDeleteAccountMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerDeleteAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof settingsControllerDeleteAccount>>, TError,void, TContext> => {

const mutationKey = ['settingsControllerDeleteAccount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof settingsControllerDeleteAccount>>, void> = () => {
          

          return  settingsControllerDeleteAccount(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SettingsControllerDeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof settingsControllerDeleteAccount>>>
    
    export type SettingsControllerDeleteAccountMutationError = unknown

    /**
 * @summary Delete the current user account
 */
export const useSettingsControllerDeleteAccount = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingsControllerDeleteAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof settingsControllerDeleteAccount>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getSettingsControllerDeleteAccountMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get checkout URL for Pro subscription
 */
export type billingControllerCreateCheckoutResponse200 = {
  data: CheckoutUrlDto
  status: 200
}

export type billingControllerCreateCheckoutResponse201 = {
  data: void
  status: 201
}
    
export type billingControllerCreateCheckoutResponseSuccess = (billingControllerCreateCheckoutResponse200 | billingControllerCreateCheckoutResponse201) & {
  headers: Headers;
};
;

export type billingControllerCreateCheckoutResponse = (billingControllerCreateCheckoutResponseSuccess)

export const getBillingControllerCreateCheckoutUrl = () => {


  

  return `/billing/checkout`
}

export const billingControllerCreateCheckout = async ( options?: RequestInit): Promise<billingControllerCreateCheckoutResponse> => {
  
  return customInstance<billingControllerCreateCheckoutResponse>(getBillingControllerCreateCheckoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getBillingControllerCreateCheckoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreateCheckout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreateCheckout>>, TError,void, TContext> => {

const mutationKey = ['billingControllerCreateCheckout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingControllerCreateCheckout>>, void> = () => {
          

          return  billingControllerCreateCheckout(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BillingControllerCreateCheckoutMutationResult = NonNullable<Awaited<ReturnType<typeof billingControllerCreateCheckout>>>
    
    export type BillingControllerCreateCheckoutMutationError = unknown

    /**
 * @summary Get checkout URL for Pro subscription
 */
export const useBillingControllerCreateCheckout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreateCheckout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingControllerCreateCheckout>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getBillingControllerCreateCheckoutMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get checkout URL for credit pack
 */
export type billingControllerCreatePackCheckoutResponse200 = {
  data: CheckoutUrlDto
  status: 200
}

export type billingControllerCreatePackCheckoutResponse201 = {
  data: void
  status: 201
}
    
export type billingControllerCreatePackCheckoutResponseSuccess = (billingControllerCreatePackCheckoutResponse200 | billingControllerCreatePackCheckoutResponse201) & {
  headers: Headers;
};
;

export type billingControllerCreatePackCheckoutResponse = (billingControllerCreatePackCheckoutResponseSuccess)

export const getBillingControllerCreatePackCheckoutUrl = (size: string,) => {


  

  return `/billing/checkout/pack/${size}`
}

export const billingControllerCreatePackCheckout = async (size: string, options?: RequestInit): Promise<billingControllerCreatePackCheckoutResponse> => {
  
  return customInstance<billingControllerCreatePackCheckoutResponse>(getBillingControllerCreatePackCheckoutUrl(size),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getBillingControllerCreatePackCheckoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>, TError,{size: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>, TError,{size: string}, TContext> => {

const mutationKey = ['billingControllerCreatePackCheckout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>, {size: string}> = (props) => {
          const {size} = props ?? {};

          return  billingControllerCreatePackCheckout(size,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BillingControllerCreatePackCheckoutMutationResult = NonNullable<Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>>
    
    export type BillingControllerCreatePackCheckoutMutationError = unknown

    /**
 * @summary Get checkout URL for credit pack
 */
export const useBillingControllerCreatePackCheckout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>, TError,{size: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingControllerCreatePackCheckout>>,
        TError,
        {size: string},
        TContext
      > => {
      return useMutation(getBillingControllerCreatePackCheckoutMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get customer portal URL
 */
export type billingControllerGetPortalUrlResponse200 = {
  data: CheckoutUrlDto
  status: 200
}
    
export type billingControllerGetPortalUrlResponseSuccess = (billingControllerGetPortalUrlResponse200) & {
  headers: Headers;
};
;

export type billingControllerGetPortalUrlResponse = (billingControllerGetPortalUrlResponseSuccess)

export const getBillingControllerGetPortalUrlUrl = () => {


  

  return `/billing/portal`
}

export const billingControllerGetPortalUrl = async ( options?: RequestInit): Promise<billingControllerGetPortalUrlResponse> => {
  
  return customInstance<billingControllerGetPortalUrlResponse>(getBillingControllerGetPortalUrlUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBillingControllerGetPortalUrlQueryKey = () => {
    return [
    `/billing/portal`
    ] as const;
    }

    
export const getBillingControllerGetPortalUrlQueryOptions = <TData = Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingControllerGetPortalUrlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>> = ({ signal }) => billingControllerGetPortalUrl({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingControllerGetPortalUrlQueryResult = NonNullable<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>>
export type BillingControllerGetPortalUrlQueryError = unknown


export function useBillingControllerGetPortalUrl<TData = Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingControllerGetPortalUrl>>,
          TError,
          Awaited<ReturnType<typeof billingControllerGetPortalUrl>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingControllerGetPortalUrl<TData = Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingControllerGetPortalUrl>>,
          TError,
          Awaited<ReturnType<typeof billingControllerGetPortalUrl>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingControllerGetPortalUrl<TData = Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer portal URL
 */

export function useBillingControllerGetPortalUrl<TData = Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetPortalUrl>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingControllerGetPortalUrlQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get subscription info
 */
export type billingControllerGetSubscriptionResponse200 = {
  data: SubscriptionInfoDto
  status: 200
}
    
export type billingControllerGetSubscriptionResponseSuccess = (billingControllerGetSubscriptionResponse200) & {
  headers: Headers;
};
;

export type billingControllerGetSubscriptionResponse = (billingControllerGetSubscriptionResponseSuccess)

export const getBillingControllerGetSubscriptionUrl = () => {


  

  return `/billing/subscription`
}

export const billingControllerGetSubscription = async ( options?: RequestInit): Promise<billingControllerGetSubscriptionResponse> => {
  
  return customInstance<billingControllerGetSubscriptionResponse>(getBillingControllerGetSubscriptionUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBillingControllerGetSubscriptionQueryKey = () => {
    return [
    `/billing/subscription`
    ] as const;
    }

    
export const getBillingControllerGetSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBillingControllerGetSubscriptionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof billingControllerGetSubscription>>> = ({ signal }) => billingControllerGetSubscription({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BillingControllerGetSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof billingControllerGetSubscription>>>
export type BillingControllerGetSubscriptionQueryError = unknown


export function useBillingControllerGetSubscription<TData = Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof billingControllerGetSubscription>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingControllerGetSubscription<TData = Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof billingControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof billingControllerGetSubscription>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBillingControllerGetSubscription<TData = Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get subscription info
 */

export function useBillingControllerGetSubscription<TData = Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof billingControllerGetSubscription>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBillingControllerGetSubscriptionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Cancel subscription at end of billing period
 */
export type billingControllerCancelSubscriptionResponse200 = {
  data: void
  status: 200
}
    
export type billingControllerCancelSubscriptionResponseSuccess = (billingControllerCancelSubscriptionResponse200) & {
  headers: Headers;
};
;

export type billingControllerCancelSubscriptionResponse = (billingControllerCancelSubscriptionResponseSuccess)

export const getBillingControllerCancelSubscriptionUrl = () => {


  

  return `/billing/subscription`
}

export const billingControllerCancelSubscription = async ( options?: RequestInit): Promise<billingControllerCancelSubscriptionResponse> => {
  
  return customInstance<billingControllerCancelSubscriptionResponse>(getBillingControllerCancelSubscriptionUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getBillingControllerCancelSubscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCancelSubscription>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof billingControllerCancelSubscription>>, TError,void, TContext> => {

const mutationKey = ['billingControllerCancelSubscription'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingControllerCancelSubscription>>, void> = () => {
          

          return  billingControllerCancelSubscription(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BillingControllerCancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof billingControllerCancelSubscription>>>
    
    export type BillingControllerCancelSubscriptionMutationError = unknown

    /**
 * @summary Cancel subscription at end of billing period
 */
export const useBillingControllerCancelSubscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerCancelSubscription>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingControllerCancelSubscription>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getBillingControllerCancelSubscriptionMutationOptions(options), queryClient);
    }
    
/**
 * @summary Resume a cancelled subscription
 */
export type billingControllerResumeSubscriptionResponse201 = {
  data: void
  status: 201
}
    
export type billingControllerResumeSubscriptionResponseSuccess = (billingControllerResumeSubscriptionResponse201) & {
  headers: Headers;
};
;

export type billingControllerResumeSubscriptionResponse = (billingControllerResumeSubscriptionResponseSuccess)

export const getBillingControllerResumeSubscriptionUrl = () => {


  

  return `/billing/subscription/resume`
}

export const billingControllerResumeSubscription = async ( options?: RequestInit): Promise<billingControllerResumeSubscriptionResponse> => {
  
  return customInstance<billingControllerResumeSubscriptionResponse>(getBillingControllerResumeSubscriptionUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getBillingControllerResumeSubscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerResumeSubscription>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof billingControllerResumeSubscription>>, TError,void, TContext> => {

const mutationKey = ['billingControllerResumeSubscription'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof billingControllerResumeSubscription>>, void> = () => {
          

          return  billingControllerResumeSubscription(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BillingControllerResumeSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof billingControllerResumeSubscription>>>
    
    export type BillingControllerResumeSubscriptionMutationError = unknown

    /**
 * @summary Resume a cancelled subscription
 */
export const useBillingControllerResumeSubscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof billingControllerResumeSubscription>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof billingControllerResumeSubscription>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getBillingControllerResumeSubscriptionMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get current user draft
 */
export type projectDraftsControllerGetDraftResponse200 = {
  data: DraftDto
  status: 200
}
    
export type projectDraftsControllerGetDraftResponseSuccess = (projectDraftsControllerGetDraftResponse200) & {
  headers: Headers;
};
;

export type projectDraftsControllerGetDraftResponse = (projectDraftsControllerGetDraftResponseSuccess)

export const getProjectDraftsControllerGetDraftUrl = () => {


  

  return `/project-drafts`
}

export const projectDraftsControllerGetDraft = async ( options?: RequestInit): Promise<projectDraftsControllerGetDraftResponse> => {
  
  return customInstance<projectDraftsControllerGetDraftResponse>(getProjectDraftsControllerGetDraftUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getProjectDraftsControllerGetDraftQueryKey = () => {
    return [
    `/project-drafts`
    ] as const;
    }

    
export const getProjectDraftsControllerGetDraftQueryOptions = <TData = Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectDraftsControllerGetDraftQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>> = ({ signal }) => projectDraftsControllerGetDraft({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectDraftsControllerGetDraftQueryResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>>
export type ProjectDraftsControllerGetDraftQueryError = unknown


export function useProjectDraftsControllerGetDraft<TData = Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>,
          TError,
          Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectDraftsControllerGetDraft<TData = Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>,
          TError,
          Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectDraftsControllerGetDraft<TData = Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user draft
 */

export function useProjectDraftsControllerGetDraft<TData = Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectDraftsControllerGetDraft>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectDraftsControllerGetDraftQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create or reset draft
 */
export type projectDraftsControllerCreateDraftResponse201 = {
  data: DraftDto
  status: 201
}
    
export type projectDraftsControllerCreateDraftResponseSuccess = (projectDraftsControllerCreateDraftResponse201) & {
  headers: Headers;
};
;

export type projectDraftsControllerCreateDraftResponse = (projectDraftsControllerCreateDraftResponseSuccess)

export const getProjectDraftsControllerCreateDraftUrl = () => {


  

  return `/project-drafts`
}

export const projectDraftsControllerCreateDraft = async (createDraftDto: CreateDraftDto, options?: RequestInit): Promise<projectDraftsControllerCreateDraftResponse> => {
  
  return customInstance<projectDraftsControllerCreateDraftResponse>(getProjectDraftsControllerCreateDraftUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createDraftDto,)
  }
);}




export const getProjectDraftsControllerCreateDraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>, TError,{data: CreateDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>, TError,{data: CreateDraftDto}, TContext> => {

const mutationKey = ['projectDraftsControllerCreateDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>, {data: CreateDraftDto}> = (props) => {
          const {data} = props ?? {};

          return  projectDraftsControllerCreateDraft(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectDraftsControllerCreateDraftMutationResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>>
    export type ProjectDraftsControllerCreateDraftMutationBody = CreateDraftDto
    export type ProjectDraftsControllerCreateDraftMutationError = unknown

    /**
 * @summary Create or reset draft
 */
export const useProjectDraftsControllerCreateDraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>, TError,{data: CreateDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectDraftsControllerCreateDraft>>,
        TError,
        {data: CreateDraftDto},
        TContext
      > => {
      return useMutation(getProjectDraftsControllerCreateDraftMutationOptions(options), queryClient);
    }
    
/**
 * @summary Update draft state
 */
export type projectDraftsControllerUpdateDraftResponse200 = {
  data: DraftDto
  status: 200
}
    
export type projectDraftsControllerUpdateDraftResponseSuccess = (projectDraftsControllerUpdateDraftResponse200) & {
  headers: Headers;
};
;

export type projectDraftsControllerUpdateDraftResponse = (projectDraftsControllerUpdateDraftResponseSuccess)

export const getProjectDraftsControllerUpdateDraftUrl = () => {


  

  return `/project-drafts`
}

export const projectDraftsControllerUpdateDraft = async (updateDraftDto: UpdateDraftDto, options?: RequestInit): Promise<projectDraftsControllerUpdateDraftResponse> => {
  
  return customInstance<projectDraftsControllerUpdateDraftResponse>(getProjectDraftsControllerUpdateDraftUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateDraftDto,)
  }
);}




export const getProjectDraftsControllerUpdateDraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>, TError,{data: UpdateDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>, TError,{data: UpdateDraftDto}, TContext> => {

const mutationKey = ['projectDraftsControllerUpdateDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>, {data: UpdateDraftDto}> = (props) => {
          const {data} = props ?? {};

          return  projectDraftsControllerUpdateDraft(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectDraftsControllerUpdateDraftMutationResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>>
    export type ProjectDraftsControllerUpdateDraftMutationBody = UpdateDraftDto
    export type ProjectDraftsControllerUpdateDraftMutationError = unknown

    /**
 * @summary Update draft state
 */
export const useProjectDraftsControllerUpdateDraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>, TError,{data: UpdateDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectDraftsControllerUpdateDraft>>,
        TError,
        {data: UpdateDraftDto},
        TContext
      > => {
      return useMutation(getProjectDraftsControllerUpdateDraftMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete draft
 */
export type projectDraftsControllerDeleteDraftResponse200 = {
  data: void
  status: 200
}
    
export type projectDraftsControllerDeleteDraftResponseSuccess = (projectDraftsControllerDeleteDraftResponse200) & {
  headers: Headers;
};
;

export type projectDraftsControllerDeleteDraftResponse = (projectDraftsControllerDeleteDraftResponseSuccess)

export const getProjectDraftsControllerDeleteDraftUrl = () => {


  

  return `/project-drafts`
}

export const projectDraftsControllerDeleteDraft = async ( options?: RequestInit): Promise<projectDraftsControllerDeleteDraftResponse> => {
  
  return customInstance<projectDraftsControllerDeleteDraftResponse>(getProjectDraftsControllerDeleteDraftUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getProjectDraftsControllerDeleteDraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>, TError,void, TContext> => {

const mutationKey = ['projectDraftsControllerDeleteDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>, void> = () => {
          

          return  projectDraftsControllerDeleteDraft(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectDraftsControllerDeleteDraftMutationResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>>
    
    export type ProjectDraftsControllerDeleteDraftMutationError = unknown

    /**
 * @summary Delete draft
 */
export const useProjectDraftsControllerDeleteDraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectDraftsControllerDeleteDraft>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getProjectDraftsControllerDeleteDraftMutationOptions(options), queryClient);
    }
    
/**
 * @summary Import project from URL (Pro only)
 */
export type projectDraftsControllerImportFromUrlResponse201 = {
  data: ImportResultDto
  status: 201
}
    
export type projectDraftsControllerImportFromUrlResponseSuccess = (projectDraftsControllerImportFromUrlResponse201) & {
  headers: Headers;
};
;

export type projectDraftsControllerImportFromUrlResponse = (projectDraftsControllerImportFromUrlResponseSuccess)

export const getProjectDraftsControllerImportFromUrlUrl = () => {


  

  return `/project-drafts/import-url`
}

export const projectDraftsControllerImportFromUrl = async (importUrlDto: ImportUrlDto, options?: RequestInit): Promise<projectDraftsControllerImportFromUrlResponse> => {
  
  return customInstance<projectDraftsControllerImportFromUrlResponse>(getProjectDraftsControllerImportFromUrlUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      importUrlDto,)
  }
);}




export const getProjectDraftsControllerImportFromUrlMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>, TError,{data: ImportUrlDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>, TError,{data: ImportUrlDto}, TContext> => {

const mutationKey = ['projectDraftsControllerImportFromUrl'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>, {data: ImportUrlDto}> = (props) => {
          const {data} = props ?? {};

          return  projectDraftsControllerImportFromUrl(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectDraftsControllerImportFromUrlMutationResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>>
    export type ProjectDraftsControllerImportFromUrlMutationBody = ImportUrlDto
    export type ProjectDraftsControllerImportFromUrlMutationError = unknown

    /**
 * @summary Import project from URL (Pro only)
 */
export const useProjectDraftsControllerImportFromUrl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>, TError,{data: ImportUrlDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectDraftsControllerImportFromUrl>>,
        TError,
        {data: ImportUrlDto},
        TContext
      > => {
      return useMutation(getProjectDraftsControllerImportFromUrlMutationOptions(options), queryClient);
    }
    
/**
 * @summary Convert draft to project
 */
export type projectDraftsControllerFinalizeDraftResponse201 = {
  data: FinalizeResultDto
  status: 201
}
    
export type projectDraftsControllerFinalizeDraftResponseSuccess = (projectDraftsControllerFinalizeDraftResponse201) & {
  headers: Headers;
};
;

export type projectDraftsControllerFinalizeDraftResponse = (projectDraftsControllerFinalizeDraftResponseSuccess)

export const getProjectDraftsControllerFinalizeDraftUrl = () => {


  

  return `/project-drafts/finalize`
}

export const projectDraftsControllerFinalizeDraft = async (finalizeDraftDto: FinalizeDraftDto, options?: RequestInit): Promise<projectDraftsControllerFinalizeDraftResponse> => {
  
  return customInstance<projectDraftsControllerFinalizeDraftResponse>(getProjectDraftsControllerFinalizeDraftUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      finalizeDraftDto,)
  }
);}




export const getProjectDraftsControllerFinalizeDraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>, TError,{data: FinalizeDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>, TError,{data: FinalizeDraftDto}, TContext> => {

const mutationKey = ['projectDraftsControllerFinalizeDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>, {data: FinalizeDraftDto}> = (props) => {
          const {data} = props ?? {};

          return  projectDraftsControllerFinalizeDraft(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectDraftsControllerFinalizeDraftMutationResult = NonNullable<Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>>
    export type ProjectDraftsControllerFinalizeDraftMutationBody = FinalizeDraftDto
    export type ProjectDraftsControllerFinalizeDraftMutationError = unknown

    /**
 * @summary Convert draft to project
 */
export const useProjectDraftsControllerFinalizeDraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>, TError,{data: FinalizeDraftDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectDraftsControllerFinalizeDraft>>,
        TError,
        {data: FinalizeDraftDto},
        TContext
      > => {
      return useMutation(getProjectDraftsControllerFinalizeDraftMutationOptions(options), queryClient);
    }
